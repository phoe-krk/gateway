;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; GATEWAY
;;;; © Michał "phoe" Herda 2016
;;;; test.lisp

(in-package #:gateway)

(begin-tests)

;;;; STANDARD-ACCEPTOR unit test, types: :N :I
(with-clean-config
  (flet ((do-test (type fn)
           (macrolet ((mk () '(make-instance 'standard-connection :type :client :port port)))
             (let* ((crown (make-instance 'standard-crown))
                    (acceptor (make-instance 'standard-acceptor :port 0 :owner crown :type type))
                    (port (get-local-port (socket acceptor)))
                    (connection-1 (mk)) (connection-2 (mk)) (connection-3 (mk))
                    (port-1 (get-local-port (socket connection-1)))
                    (port-2 (get-local-port (socket connection-2)))
                    (port-3 (get-local-port (socket connection-3)))
                    (data '(dummy test object)))
               (send connection-1 data) (send connection-2 data) (send connection-3 data)
               (labels
                   ((form (data) (format nil "~S" (sexp data)))
                    (find-conn (port) (find port (funcall fn crown) :key (compose #'get-peer-port #'socket)))
                    (test (port)
                      (loop do (sleep 0.01) until (find-conn port))
                      (assert (equal (form data) (form (receive (find-conn port)))))))
                 (mapc #'test (list port-1 port-2 port-3)))
               (mapc #'kill (list acceptor connection-1 connection-2 connection-3))))))
    (do-test :n #'n-connections)
    (do-test :i #'i-connections)))

;;;; STANDARD-CONNECTION unit test
(with-clean-config
  (labels ((check-conns () (assert (null (maphash #'list *connection-cache*)))))
    (kill (make-instance 'standard-connection :type :listen :port 0))
    (check-conns)
    (macrolet ((mkcn (&body body) `(make-instance 'standard-connection ,@body)))
      (with-connections
          ((listen (mkcn :type :listen :port 0))
           (client (mkcn :type :client :port (get-local-port (socket listen))))
           (accept (mkcn :type :accept :socket (socket listen))))
        (labels ((form (data) (format nil "~S" (sexp data)))
                 (test (x y data)
                   (send x data)
                   (assert (readyp y)) 
                   (assert (equal (form (receive y)) (form data))))
                 (test-case (data)
                   (test client accept data)
                   (test accept client data)))
          (let ((test-cases '((1 2 3 4 5 6 7 8 9 0)
                              (a b c d e f)
                              (lorem ipsum dolor sit amet)
                              ("a" a "a" a "a" "b"))))
            (mapcar #'test-case test-cases)))))
    (check-conns)))

;;;; STANDARD-CROWN unit test
(let ((crown (make-instance 'standard-crown)))
  (assert (library crown))
  (assert (event-queue crown))
  (assert (null (gems crown)))
  (assert (null (n-acceptor crown)))
  (assert (null (n-connections crown)))
  (assert (n-lock crown))
  (assert (null (n-listener crown))) 
  (assert (null (e-connections crown)))
  (assert (e-lock crown))
  (assert (null (e-listener crown)))
  (assert (null (i-acceptor crown)))
  (assert (null (i-connections crown)))
  (assert (i-lock crown))
  (assert (null (i-listener crown)))
  (assert (null (alivep crown))))

;;;; STANDARD-DATE unit test
(flet ((mkdt (day sec nsec) (make-instance 'standard-date :day day :sec sec :nsec nsec)))
  (let* ((date-orig (mkdt 0 0 0)) (date-same (mkdt 0 0 0)) (date-nsec (mkdt 0 0 1))
         (date-sec (mkdt 0 1 0)) (date-min (mkdt 0 60 0)) (date-hour (mkdt 0 3600 0))
         (date-day (mkdt 1 0 0)) (date-month (mkdt 31 0 0)) (date-year (mkdt 365 0 0))
         (vars (list date-orig date-nsec date-sec date-min date-hour date-day date-year)))
    (assert (date= date-orig date-same))
    (assert (date= date-orig date-same :unit :nanosecond))
    (assert (date= date-orig date-nsec :unit :second))
    (assert (date= date-orig date-sec :unit :minute))
    (assert (date= date-orig date-min :unit :hour))
    (assert (date= date-orig date-hour :unit :day))
    (assert (date= date-orig date-day :unit :month))
    (assert (date= date-orig date-month :unit :year))
    (assert (date/= date-orig date-nsec))
    (assert (date/= date-orig date-sec))
    (assert (date/= date-orig date-min))
    (assert (date/= date-orig date-hour))
    (assert (date/= date-orig date-day))
    (assert (date/= date-orig date-month))
    (assert (date/= date-orig date-year))
    (assert (date/= date-orig date-sec :unit :nanosecond))
    (assert (date/= date-orig date-min :unit :second))
    (assert (date/= date-orig date-hour :unit :minute))
    (assert (date/= date-orig date-day :unit :hour))
    (assert (date/= date-orig date-month :unit :day))
    (assert (date/= date-orig date-year :unit :month))
    (assert (date< date-orig date-nsec))
    (assert (date< date-nsec date-sec))
    (assert (date< date-sec date-min))
    (assert (date< date-min date-hour))
    (assert (date< date-hour date-day))
    (assert (date< date-day date-month))
    (assert (date< date-month date-year))
    (assert (date> date-nsec date-orig))
    (assert (date> date-sec date-nsec))
    (assert (date> date-min date-sec))
    (assert (date> date-hour date-min))
    (assert (date> date-day date-hour))
    (assert (date> date-month date-day))
    (assert (date> date-year date-month))
    (assert (eq date-orig (apply #'date-min vars)))
    (assert (eq date-year (apply #'date-max vars)))
    (assert (date= date-orig (parse (sexp date-orig))))))

;;;; STANDARD-LIBRARY unit test
(let ((library (make-instance 'standard-library))
      (number-1 (random #.(expt 2 15)))
      (number-2 (random #.(expt 2 15)))
      (number-3 (random #.(expt 2 15))))
  (setf (lookup library '(a a 1)) number-1)
  (assert (= (lookup library '(a a 1)) number-1))
  (setf (lookup library '(a a 1)) number-2)
  (assert (= (lookup library '(a a 1)) number-2)) 
  (setf (lookup library '(a b 1)) number-3)
  (assert (= (lookup library '(a b 1)) number-3)))

;;;; STANDARD-LISTENER unit test, types: :N :E :I
(with-clean-config 
  (macrolet ((mk () '(make-instance 'standard-connection :type :client :port port))
             (amk () '(make-instance 'standard-connection :type :accept :socket (socket connection)))
             (dq () '(dequeue queue))
             (do-test (conn-fn lock-fn type)
               `(let* ((crown (make-instance 'standard-crown))
                       (queue (event-queue crown)) 
                       (connection (make-instance 'standard-connection :port 0 :type :listen))
                       (port (get-local-port (socket connection))) 
                       (connection-1 (mk)) (aconnection-1 (amk))
                       (connection-2 (mk)) (aconnection-2 (amk))
                       (connection-3 (mk)) (aconnection-3 (amk))
                       (conns (list connection-1 connection-2 connection-3))
                       (aconns (list aconnection-1 aconnection-2 aconnection-3)) 
                       (listener (make-instance 'standard-listener :owner crown :type ,type))
                       (data '(dummy test object)))
                  (with-lock-held ((,lock-fn crown))
                    (setf (,conn-fn crown) aconns))
                  (send connection-1 (cons 'first data))
                  (send connection-2 (cons 'second data))
                  (send connection-3 (cons 'third data))
                  (loop do (sleep 0.01) until (= 3 (size queue)))
                  (flet ((form (data) (format nil "~S" (sexp data))))
                    (let ((queue-data (mapcar (compose #'form #'caddr) (list (dq) (dq) (dq))))
                          (expected (mapcar #'form (list (cons 'first data) (cons 'second data)
                                                         (cons 'third data)))))
                      (flet ((find-data (x) (find x queue-data :test #'equal)))
                        (assert (every #'identity (mapcar #'find-data expected))))))
                  (kill listener)
                  (mapc (lambda (x) (push x (,conn-fn crown))) conns)
                  (mapc #'kill (cons connection conns))
                  (mapc #'kill aconns))))
    (do-test n-connections n-lock :n)
    (do-test e-connections e-lock :e)
    (do-test i-connections i-lock :i)))

;;;; STANDARD-PASSWORD unit test
(progn
 ;;;; Commented out for speed, as password hashing takes time.
  ;; (let ((wrong-passphrase "Wr0ng-Pas$w0rd"))
  ;;   (flet ((check-password (passphrase)
  ;;            (let ((password (make-password passphrase)))
  ;;              (assert (password-matches-p password passphrase))
  ;;              (assert (not (password-matches-p password wrong-passphrase))))))
  ;;     (mapcar #'check-password
  ;;             '("" "pass" "password-1" "password-2PassW0RD"
  ;;               "password-2ĄŚÐΩŒĘ®ĘŒ®ÐÆąęea
  ;; ÆŃ±¡¿¾   £¼‰‰ę©œ»æśððæś"))))
  )

;;;; STANDARD-GEM unit test
(with-clean-config
  (macrolet ((mk () '(make-instance 'standard-connection :type :client :port port))
             (amk () '(make-instance 'standard-connection :type :accept :socket (socket connection))))
    (let* ((crown (make-instance 'standard-crown))
           (queue (event-queue crown))
           (connection (make-instance 'standard-connection :port 0 :type :listen))
           (port (get-local-port (socket connection)))
           (connection-1 (mk)) (aconnection-1 (amk))
           (connection-2 (mk)) (aconnection-2 (amk))
           (connection-3 (mk)) (aconnection-3 (amk))
           (gem (make-instance 'standard-gem :owner crown))
           (ping '(#:ping (#:test #:dummy 1234 "abcABC")))
           (pong (cons '#:pong (cdr ping))))
      (with-lock-held ((n-lock crown))
        (push aconnection-1 (n-connections crown)))
      (with-lock-held ((e-lock crown))
        (push aconnection-2 (e-connections crown)))
      (with-lock-held ((i-lock crown))
        (push aconnection-3 (i-connections crown)))
      (enqueue (list :n aconnection-1 ping) queue)
      (flet ((form (data) (format nil "~S" (sexp data))))
        (let ((received-pong (receive connection-1))) 
	  (assert (string= (form pong) (form received-pong)))))
      (kill connection-1)
      (kill connection-2)
      (kill connection-3)
      (receive aconnection-1)
      (receive aconnection-2)
      (receive aconnection-3)
      (loop do (sleep 0.01)
            until (and (empty? queue)
                       (null (n-connections crown))
                       (null (e-connections crown))
                       (null (i-connections crown))))
      (kill gem)
      (kill crown)
      (mapc #'kill (list connection connection-1 connection-2 connection-3
                         aconnection-1 aconnection-2 aconnection-3)))))

;;;; Integration test - TODO fix open-gateway
;; (with-clean-config
;;   (let* ((crown (make-instance 'standard-crown :full t))
;;          (n-port (get-local-port (socket (n-acceptor crown))))
;;          (connection-1 (make-instance 'standard-connection :port n-port :type :client))
;;          (connection-2 (make-instance 'standard-connection :port n-port :type :client))
;;          (connection-3 (make-instance 'standard-connection :port n-port :type :client)))
;;     (format t "Ping 1!~%")
;;     (send connection-1 '(open gateway))
;;     (format t "Ping 2!~%")
;;     (send connection-2 '(open gateway))
;;     (format t "Ping 3!~%")
;;     (send connection-3 '(open gateway))
;;     (format t "Ping 4!~%")
;;     (loop do (sleep 0.01) until (= 3 (length (e-connections crown))))
;;     (format t "Ping 5!~%")
;;     ;; TODO: finish
;;     (mapcar #'kill (list connection-1 connection-2 connection-3)) 
;;     (format t "Ping 6!~%")
;;     (kill crown)))

(finish-tests)
